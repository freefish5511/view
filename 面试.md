### 粗聊:
1, 简单介绍自己
2, 做过哪些项目,挑两个最熟悉的项目讲讲吧?这个项目的技术架构?这个项目的亮点在哪?难点在哪?(怎么解决的?可能会插问項目里渉及的东西。

##### 基础:
###### 1, 接口和抽象类的区别
```
一) 继承方面：
       (1) 抽象类只能单继承；接口可以多实现
(二) 成员属性方面：
       (1) 抽象类中可以有普通属性，也可以有常量
       (2) 接口中的成员变量全部默认是常量，使用public static final修饰，这个可以省略不写
(三) 代码块方面：
       (1) 抽象类可以含初始化块；接口不能含初始化块
(四) 构造函数方面：
       (1) 接口不能有构造函数
       (2) 抽象类可以有构函数，但是这里的构造函数不是用来创建对象的，而且用来被实现类调用进行初始化操作的
(五) 方法方面：
       (1) 接口里面不能定义静态方法；抽象类里面可以定义静态方法
       (2) 接口里面只能是抽象方法；抽象类里面可以有抽象方法也可以有普通方法

上面就是接口与抽象类的区别，在说完区别之后，我们可以补充一下接口与抽象类之间的相同之处：
(1) 接口与抽象类都不能被实例化，需要被其他进行实现或继承
(2) 接口与抽象类里面都能包含抽象方法，实现接口或继承抽象类的子类都必须实现这些抽象方法
针对相同之处的第二点，我再细说一下
(一) 超类是接口：
       (1) 如果使用接口继承(extends，无法使用implements)这个接口，那么在这个子类接口中，可以实现其父类接口中的抽象方法（这种方法我从没看见过，但是在今天的面试中，面试官问我接口中是否可以有具体的实现方法，可以将这种情况举出来）
       (2) 如果使用抽象类实现这个接口，可以在这个子类抽象类中实现父类接口中的抽象方法
       (3) 如果使用具体类实现这个接口，那么就必须实现父类接口中的所有抽象方法
(二) 超类是抽象类：
       (1) 接口不能继承抽象类
       (2) 如果使用抽象类继承这个抽象类，可以在这个子类抽象类中实现父类接口中的抽象方法
       (3) 如果使用具体类继承这个抽象类，那么就必须实现父类抽象类中的所有抽象方法

对于上面的说明，所以在相同之处的第二点处主要是针对具体类继承抽象类或实现接口来说的。
```
###### 2, 线程和进程区?线程有哪些状态?开发中怎么保证多线程安全?死锁?
```
根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位。  
地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间。  
关系：一个程序至少一个进程，一个进程至少一个线程。

线程安全就是多线程访问同一代码，不会产生不确定的结果。
如何保证线程安全:
1.对非安全的代码进行加锁控制；
2.使用线程安全的类；
3.多线程并发情况下，线程共享的变量改为方法级的局部变量。
```
###### 3, 面向対象的大特性? 什么是多态?实现多态的条件?多态优点?
```
封装、继承和多态.

简单点说
多态是指程序中同名的不同方法共存的情况
多态就是同一操作（方法）作用于不同的对象时，可以有不同的解释，产生不同的执行结果。
这句话看似简单，实则颇有深意。 当父类引用指向子类实例的时候，由于子类对父类的方法进行了重写，
在调用该方法的时候表现出的不同就称为多态

Java实现多态有三个必要条件：继承、重写、向上转型。
实现形式:  在Java中有两种形式可以实现多态。  
1.继承父类  
2.实现接口

多态的特点大大提高了程序的抽象程度和简洁性，更重要的是它最大限度地降低了类和程序模块之间的耦合性，
提高了类模块的封闭性，使得它们不需了解对方的具体细节，就可以很好地共同工作。
这个优点，对程序的设计、开发和维护都有很大的好处。
```
###### 4, 解释下springBoot的bean的理解;什么是注解?如何理解starter?
```

```
###### 5, cookie和session的区别?
![[Pasted image 20220326090348.png]]

###### 6, 事务有哪几个特性?哪几个隔离级别?
```
一、事务的基本要素（ACID）
1、原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。
2、一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。
3、隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。
4、持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。
二、事务的并发问题
1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据
2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。
3、幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。
小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表
事务隔离级别	               脏读	不可重复读	幻读
读未提交（read-uncommitted） |是   |是     |是
不可重复读（read-committed）  |否  |是     |是
可重复读（repeatable-read）  |否   |否     |是
串行化（serializable）       |否	 |否     |否
```

###### 7, 缓存有哪些类型?什么是多级缓存?主从复制?
A.客户端缓存：对于BS架构的互联网应用来说客户端缓存主要分为页面缓存和浏览器缓存两种，对于APP而言主要是自身所使用的缓存。
B.网络中缓存：网络中的缓存主要是指代理服务器对客户端请求数据的缓存，主要分为WEB代理缓存和边缘缓存(CDN边缘缓存)
C.服务端缓存：对于服务端缓存而言，从系统的架构上面区分可以将缓存分为
    服务器本读缓存(localCache)
    分布式缓存(Redis、Memcached等nosql)
D.数据库缓存

##### 进阶考蔡:
###### 1, 有了解过些设计模式吗?了解SOLID原则吗?解释下开放封闭原则和依赖倒置原则。
```
一里地单开结
单一职责原则（SRP）
开放封闭原则（OCP）
里氏替换原则（LSP）
接口隔离原则（ISP）
依赖倒置原则（DIP）

开放封闭原则
一个类应该对扩展开放，对修改关闭。这意味一旦你创建了一个类并且应用程序的其他部分开始使用它，你不应该修改它。为什么呢？因为如果你改变它，很可能你的改变会引发系统的崩溃。如果你需要一些额外功能，你应该扩展这个类而不是修改它。使用这种方式，现有系统不会看到任何新变化的影响。同时，你只需要测试新创建的类。

依赖倒置原则（DIP）表明高层模块不应该依赖低层模块，相反，他们应该依赖抽象类或者接口。这意味着你不应该在高层模块中使用具体的低层模块。因为这样的话，高层模块变得紧耦合低层模块。如果明天，你改变了低层模块，那么高层模块也会被修改。根据DIP原则，高层模块应该依赖抽象（以抽象类或者接口的形式），低层模块也是如此。通过面向接口（抽象类）编程，紧耦合被移除。
那么什么是高层模块，什么是低层模块呢？通常情况下，我们会在一个类（高层模块）的内部实例化它依赖的对象（低层模块），这样势必造成两者的紧耦合，任何依赖对象的改变都将引起类的改变。
依赖倒置原则表明高层模块、低层模块都依赖于抽象
```
###### 2, 微服务网关的作用?什么是负载均衡?SSO和SOA区别?
```
（1）统一入口：为全部微服务提供唯一入口点，网关起到内部和外部隔离，保障了后台服务的安全性。
（2）鉴权校验：识别每个请求的 权限，拒绝不符合要求的请求。
（3）动态路由：动态的将请求 路由 到不同的后端集群中。
（4）降低耦合度：减少客户端与服务的耦合 ，服务可以独立发展。通过网关层来做映射。

负载均衡是微服务架构中必须使用的技术，通过负载均衡来实现系统的高可用、集群扩容等功能。负载均衡可通过硬件设备及软件来实现，硬件比如：F5、Array等 ，软件比如：LVS、Nginx等 。
负载均衡算法有：轮训、随机、加权轮训、加权随机、地址哈希等方法，负载均衡器维护一份服务列表，根据负载均衡算法将请求转发到相应的微服务上，所以负载均衡可以为微服务集群分担请求，降低系统的压力。

单点登录SSO（Single Sign On）
对于分布式系统来说，我们需要sso这样一个用于单点登录的系统，可以独立部署在一个web服务器内，
比如域名为 [http://login.abc.com]，其他所有web服务上的登录都可以通过这个sso来登录

SOA（面向服务的架构）是集成多个较大组件（应用）的一种机制，它们将整体构成一个彼此协作的套件。比如企业ERP、CRM、OA等系统一般都是由不同供应商开发的，技术差别和系统接口差异比较大，系统之间互相访问困难，于是就出现了esb（企业服务总线），统一访问的方式。这个就是SOA的探索，所以SOA强调的是系统之间的协作，访问方式的统一。
系统集成：站在系统的角度，解决企业系统间的通信问 题，把原先散乱、无规划的系统间的网状结构，梳理成 规整、可治理的系统间星形结构，这一步往往需要引入 一些产品，比如 ESB、以及技术规范、服务管理规范； 这一步解决的核心问题是【有序】

系统的服务化：站在功能的角度，把业务逻辑抽象成 可复用、可组装的服务，通过服务的编排实现业务的 快速再生，目的：把原先固有的业务功能转变为通用 的业务服务，实现业务逻辑的快速复用；这一步解决 的核心问题是【复用】
服务化：站在企业的角度，把企业职能抽象成 可复用、可组装的服务；把原先职能化的企业架构转变为服务化的企业架构，进一步提升企业的对外服务能力；“前面两步都是从技术层面来解决系统调用、系统功能复用的问题”。第三步，则是以业务驱动把一个业务单元封装成一项服务。这一步解决的核心问题是【高效】**
```
###### 3, 解释下你对元数据的理解;对多租户概念的理解?为什么要打造元数据驱动的多租户产品？
SaaS是Software-as-a-Service（软件即服务）的简称，是一种软件布局模型，其应用专为网络交付而设计，便于用户通过互联网托管、部署及接入。



###### 4, 了解DDD模型吗?解释下DDD代码架构4层的用法
“领域模型”就是“解决方案空间”，是针对特定领域里的关键事物及其关系的可视化表现，是为了准确定义需要解决问题而构造的抽象模型，是业务功能场景在软件系统里的映射转化，其目标是为软件系统构建统一的认知。

- 领域驱动设计关心的是业务中的领域划分（战略设计）和领域建模（战术设计），其开发过程不再以数据模型为起点，而是以领域模型为出发点，研发过程如图2所示。领域模型对应的是业务实体，在程序中主要表现为类、聚合根和值对象，它更加关注业务语义的显性化表达，而不是数据的存储和数据之间的关系

-   用户接口层：响应外部数据，例如controller，ajx，或者别的协议
-   应用层：组织业务逻辑
-   领域层：由实体和值对象组成，每个领域是有自己的业务核心的，领域与领域之间通过领域服务来进行跨领域的调用
-   基础层：所有业务的支撑

###### 5, 要实现系统高可用,有哪些想法?要实现一个系统的数据库宕机了仍可用,有什么想法?
高可用HA（High Availability）是分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计减少系统不能提供服务的时间。

方法论上，高可用是通过冗余+自动故障转移来实现的。

整个互联网分层系统架构的高可用，又是通过每一层的冗余+自动故障转移来综合实现的，具体的：

（1）【客户端层】到【反向代理层】的高可用，是通过反向代理层的冗余实现的，常见实践是keepalived + virtual IP自动故障转移

（2）【反向代理层】到【站点层】的高可用，是通过站点层的冗余实现的，常见实践是nginx与web-server之间的存活性探测与自动故障转移

（3）【站点层】到【服务层】的高可用，是通过服务层的冗余实现的，常见实践是通过service-connection-pool来保证自动故障转移

（4）【服务层】到【缓存层】的高可用，是通过缓存数据的冗余实现的，常见实践是缓存客户端双读双写，或者利用缓存集群的主从数据同步与sentinel保活与自动故障转移；更多的业务场景，对缓存没有高可用要求，可以使用缓存服务化来对调用方屏蔽底层复杂性

（5）【服务层】到【数据库“读”】的高可用，是通过读库的冗余实现的，常见实践是通过db-connection-pool来保证自动故障转移

（6）【服务层】到【数据库“写”】的高可用，是通过写库的冗余实现的，常见实践是keepalived + virtual IP自动故障转移

###### 6, 性能优化:要优化用户的页面体验,对前中后台分别有哪些思考?
```

```
###### 7, 什么是swagger?你觉得如何才能设计出优秀的API?
1，API接口都用小写
2，使用JSON通信
3，API带版本控制，比如v1,v2
4，使用Token令牌进行鉴权
5，路径中单词连接使用中划线-
6，使用HTTP自身的方法表示增删改查资源， GET：查询，POST：新增，PUT：更新，DELETE：删除
7，合理使用HTTP状态码，200，201，400，401，403，500。比如401表示用户身份认证失败，403表示你验证身份通过了，但是无权限操作资源。

###### 8, 我们的接口层拆分v1层和v2层,你觉得这样拆分有什么好处?
```

```
###### 9, 从架构设计上来说,怎样能打造好用的低代码模板化平台?

Q1：是否支持协同开发和版本管理？
Q2：是否支持自由设计数据库结构？
Q3：能否灵活自由地设计显示页面？
Q4：能否支持前后端分离的系统架构，后端复杂逻辑如何解决？
Q5：是否有全系统模块的解决方案？
Q6：如何保证开发出应用的系统安全性？
Q7：平台是否独立，能够不依赖其他第三方的产品?
Q8：是否会产生新的“数据孤岛”？
Q9：该平台的产品生态建设如何，是否有激励机制？
-   模板：模板也叫开发成果，是指开发者使用低代码平台为特定行业或场景构建的“半成品”系统。基于半成品进行二次开发，可以进一步提升企业应用的构建速度。成熟的低代码平台通常具备模板市场，通过商务和技术手段，鼓励开发者将自己使用该平台开发出的应用放在市场中分享或销售，打造“人人为我，我为人人”的正向循环。
-   插件：低代码平台通常会开放插件机制，以吸引更多开发者封装自己开发的“模块”。插件和平台在一起运行，让低代码平台的应用场景更丰富。事实上，一家平台厂商的技术能力再强，也不能全部满足客户的所有需求。只有开放插件机制，建立插件付费环境，才能让广大的开发者都参于进来，共同打造更强大的平台。

###### 10, 对大数据、AI了解吗？
```

```